<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Conversation Mind Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<script src="https://unpkg.com/vis-network@9.1.7/dist/vis-network.min.js"></script>
<link href="https://unpkg.com/vis-network@9.1.7/styles/vis-network.min.css" rel="stylesheet"/>

<style>
  :root {
    --bg: #ffffff;
    --fg: #263238;
    --edge: #CFD8DC;
    --root: #B2DFDB;
    --topic: #C5CAE9;
    --subtopic: #BBDEFB;
    --leaf: #E1F5FE;
    --highlight: #FFE082;
  }
  body { margin:0; background:var(--bg); color:var(--fg); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
  .toolbar {
    display:flex; gap:.75rem; flex-wrap:wrap; align-items:center;
    padding:.75rem 1rem; border-bottom:1px solid #ECEFF1; position:sticky; top:0; background:rgba(255,255,255,.97); z-index:10;
  }
  .toolbar label { font-size:.9rem; opacity:.9; }
  .toolbar input[type="range"] { width:160px; vertical-align:middle; }
  .toolbar input[type="text"] { width:220px; padding:.4rem .55rem; border:1px solid #ECEFF1; border-radius:8px; }
  .toolbar select { padding:.35rem .5rem; border:1px solid #ECEFF1; border-radius:8px; }
  .pill { display:inline-block; padding:.15rem .45rem; font-size:.75rem; border-radius:999px; background:#EEF2F7; margin-left:.35rem; }
  #graph { height: calc(100vh - 64px); }
  .note { padding:.35rem 1rem; font-size:.85rem; color:#607D8B; border-top:1px dashed #ECEFF1; }
</style>
</head>

<body>
  <div class="toolbar">
    <label>Branch
      <select id="topic"></select>
    </label>

    <label>Depth
      <input id="depth" type="range" min="1" max="8" step="1" value="8"/>
      <span id="depthVal" class="pill">8</span>
    </label>

    <label>Wrap
      <input id="wrap" type="range" min="14" max="36" step="1" value="36"/>
      <span id="wrapVal" class="pill">36</span>
    </label>

    <label>Layout
      <!-- üîπ default direction changed from LR ‚Üí UD -->
      <select id="direction">
        <option value="UD" selected>Top ‚Üí Down</option>
        <option value="LR">Left ‚Üí Right</option>
      </select>
    </label>

    <label><input id="hideX" type="checkbox" checked/> Hide cross-links</label>
    <label><input id="edgeLabels" type="checkbox" checked/> Show speaker labels on edges</label>

    <label>Highlight
      <input id="search" type="text" placeholder="type to highlight‚Ä¶"/>
    </label>

    <span id="stats" class="pill"></span>
  </div>

  <div id="graph"></div>
  <div class="note">Tip: Choose one branch (topic) and keep depth at 2‚Äì3 for clarity. Toggle ‚ÄúShow speaker labels‚Äù to see who introduced/discussed each node.</div>

<script>
  // -------- Embedded Data --------
  const DATA = {"conversation_title": "NBA Discussion: Favorite Teams, Draft Picks, and Player Performance", "participants": [{"name": "Adil Gazder"}, {"name": "Lewis Hamilton"}], "main_topics": [{"topic": "Favorite Sport & NBA Team", "introduced_by": "Adil Gazder", "introduced_at": "00:00:01", "sentiment": "neutral", "subtopics": [{"subtopic": "Lewis's Favorite Sport (Basketball)", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:04", "stance": "neutral", "targeted_at": "Favorite Sport & NBA Team", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "neutral"}, {"subtopic": "Lewis's Favorite NBA Team (OKC)", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:09", "stance": "neutral", "targeted_at": "Favorite Sport & NBA Team", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "neutral"}]}, {"topic": "OKC's 2025 NBA Draft Picks", "introduced_by": "Adil Gazder", "introduced_at": "00:00:10", "sentiment": "neutral", "subtopics": [{"subtopic": "Quality of OKC's 2025 Draft Picks", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:14", "stance": "elaboration", "targeted_at": "OKC's 2025 NBA Draft Picks", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "negative"}, {"subtopic": "Origin of Draft Picks (Good Basketball Schools)", "introduced_by": "Adil Gazder", "introduced_at": "00:00:23", "stance": "question", "targeted_at": "Quality of OKC's 2025 Draft Picks", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "neutral"}]}, {"topic": "Cooper Flag's Performance in Dallas", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:25", "sentiment": "negative", "subtopics": [{"subtopic": "Adil's View on Cooper Flag's Performance", "introduced_by": "Adil Gazder", "introduced_at": "00:00:32", "stance": "support", "targeted_at": "Cooper Flag's Performance in Dallas", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "positive"}, {"subtopic": "Lewis's Counter-Argument on Cooper Flag's Performance", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:34", "stance": "challenge", "targeted_at": "Adil's View on Cooper Flag's Performance", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "negative"}, {"subtopic": "Cooper Flag's On-Court Plus/Minus Stats", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:39", "stance": "elaboration", "targeted_at": "Lewis's Counter-Argument on Cooper Flag's Performance", "discussed_by": ["Lewis Hamilton"], "sentiment": "negative"}, {"subtopic": "Cooper Flag's Averaging Points", "introduced_by": "Adil Gazder", "introduced_at": "00:00:45", "stance": "question", "targeted_at": "Lewis's Counter-Argument on Cooper Flag's Performance", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "neutral"}, {"subtopic": "Source of Cooper Flag Performance Information", "introduced_by": "Lewis Hamilton", "introduced_at": "00:00:53", "stance": "challenge", "targeted_at": "Cooper Flag's Averaging Points", "discussed_by": ["Adil Gazder", "Lewis Hamilton"], "sentiment": "negative"}]}], "relationships": [{"from": "Lewis's Favorite Sport (Basketball)", "to": "Favorite Sport & NBA Team", "type": "elaboration", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:04"}, {"from": "Lewis's Favorite NBA Team (OKC)", "to": "Favorite Sport & NBA Team", "type": "elaboration", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:09"}, {"from": "Quality of OKC's 2025 Draft Picks", "to": "OKC's 2025 NBA Draft Picks", "type": "elaboration", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:14"}, {"from": "Origin of Draft Picks (Good Basketball Schools)", "to": "Quality of OKC's 2025 Draft Picks", "type": "question", "initiated_by": "Adil Gazder", "initiated_at": "00:00:23"}, {"from": "Cooper Flag's Performance in Dallas", "to": "Quality of OKC's 2025 Draft Picks", "type": "extension", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:25"}, {"from": "Adil's View on Cooper Flag's Performance", "to": "Cooper Flag's Performance in Dallas", "type": "challenge", "initiated_by": "Adil Gazder", "initiated_at": "00:00:32"}, {"from": "Lewis's Counter-Argument on Cooper Flag's Performance", "to": "Adil's View on Cooper Flag's Performance", "type": "challenge", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:34"}, {"from": "Cooper Flag's On-Court Plus/Minus Stats", "to": "Lewis's Counter-Argument on Cooper Flag's Performance", "type": "elaboration", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:39"}, {"from": "Cooper Flag's Averaging Points", "to": "Lewis's Counter-Argument on Cooper Flag's Performance", "type": "challenge", "initiated_by": "Adil Gazder", "initiated_at": "00:00:45"}, {"from": "Source of Cooper Flag Performance Information", "to": "Cooper Flag's Averaging Points", "type": "challenge", "initiated_by": "Lewis Hamilton", "initiated_at": "00:00:53"}], "metadata": {"conversation_length": "00:01:00", "source_file": "namedREALTIME_transcript.txt", "generated_on": "2025-11-09T09:45:48.148432", "llm_model": "gemini-1.5-pro"}};

  // -------- UI refs --------
  const topicSel   = document.getElementById('topic');
  const depthEl    = document.getElementById('depth');
  const depthVal   = document.getElementById('depthVal');
  const wrapEl     = document.getElementById('wrap');
  const wrapVal    = document.getElementById('wrapVal');
  const dirEl      = document.getElementById('direction');
  const hideX      = document.getElementById('hideX');
  const edgeLabels = document.getElementById('edgeLabels');
  const searchEl   = document.getElementById('search');
  const statsEl    = document.getElementById('stats');

  // Populate topics
  const TOPICS = ["All Topics", ...(DATA.main_topics||[]).map(t => t.topic).filter(Boolean)];
  TOPICS.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t; opt.textContent = t;
    topicSel.appendChild(opt);
  });

  depthEl.addEventListener('input', () => depthVal.textContent = depthEl.value);
  wrapEl .addEventListener('input', () => wrapVal.textContent  = wrapEl.value);

  // -------- Utils --------
  function wrapLabel(s, width) {
    s = (s||"").trim().replace(/\s+/g, " ");
    if (s.length <= width) return s;
    const out = []; let line = [], ln = 0;
    for (const w of s.split(" ")) {
      const extra = line.length ? 1 : 0;
      if (ln + w.length + extra > width) {
        out.push(line.join(" ")); line=[w]; ln = w.length;
      } else { line.push(w); ln += w.length + extra; }
    }
    if (line.length) out.push(line.join(" "));
    return out.join("<br>");
  }

  function tint(hex, sentiment) {
    if (!sentiment || sentiment === "neutral") return hex;
    const r = parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
    let R=r,G=g,B=b;
    if (sentiment === "positive") { R=Math.min(255, Math.round(r*1.10)); G=Math.min(255, Math.round(g*1.10)); B=Math.min(255, Math.round(b*1.10)); }
    if (sentiment === "negative") { R=Math.round(r*0.80); G=Math.round(g*0.80); B=Math.round(b*0.80); }
    return "#" + [R,G,B].map(v => v.toString(16).padStart(2,"0")).join("");
  }

  function truncateList(list, maxItems=3) {
    if (!Array.isArray(list)) return "";
    const items = list.filter(Boolean);
    if (items.length <= maxItems) return items.join(", ");
    return items.slice(0, maxItems).join(", ") + " +" + (items.length - maxItems);
  }

  // -------- Build graph data (edge attribution) --------
  function buildData(opts) {
    const {
      selectedTopic = "All Topics",
      maxDepth = 10,
      hideCrosslinks = false,
      wrap = 36,
      showEdgeLabels = true
    } = opts;

    const nodes = new vis.DataSet();
    const edges = new vis.DataSet();

    const palette = {
      root:     getComputedStyle(document.documentElement).getPropertyValue('--root').trim(),
      topic:    getComputedStyle(document.documentElement).getPropertyValue('--topic').trim(),
      subtopic: getComputedStyle(document.documentElement).getPropertyValue('--subtopic').trim(),
      leaf:     getComputedStyle(document.documentElement).getPropertyValue('--leaf').trim()
    };

    const addNode = (id, role, label, sentiment) => {
      if (!id || nodes.get(id)) return;
      const color = tint(palette[role] || palette.leaf, sentiment);
      nodes.add({
        id,
        label: wrapLabel(label||id, wrap),
        title: label||id,
        color,
        shape: "box",
        margin: 10,
        font: { multi: "html", size: 14 }
      });
    };

    const addEdge = (from, to, label, title) => {
      if (!from || !to) return;
      const e = { from, to };
      if (showEdgeLabels && label) e.label = label;
      if (title) e.title = title;
      edges.add(e);
    };

    const root = DATA.root || DATA.title || "Mind Map";
    addNode(root, "root", root);

    // Edge attribution for topics: "introduced by ..."
    function addTopicBranch(topicObj) {
      const tname = topicObj.topic;
      addNode(tname, "topic", tname, topicObj.sentiment);

      let topicEdgeLabel = "";
      let topicEdgeTitle = "";
      const introBy = topicObj.introduced_by;
      const introAt = topicObj.introduced_at;
      if (introBy) {
        topicEdgeLabel = "introduced by " + introBy;
        topicEdgeTitle = "<b>introduced by</b>: " + introBy + (introAt ? "<br><b>at</b>: " + introAt : "");
      }
      addEdge(root, tname, topicEdgeLabel, topicEdgeTitle);

      // Subtopics: attribution from discussed_by / stance goes on the edge Topic‚ÜíSubtopic
      for (const s of (topicObj.subtopics || [])) {
        const sname = s.subtopic;
        addNode(sname, "subtopic", sname, s.sentiment);

        const whoList = (s.discussed_by || []).filter(Boolean);
        const stance  = s.stance;
        const labelWho = truncateList(whoList, 2);
        let subEdgeLabel = "";
        let subEdgeTitle = "";
        if (labelWho || stance) {
          const parts = [];
          if (labelWho) parts.push("discussed by " + labelWho);
          if (stance)   parts.push("stance: " + stance);
          subEdgeLabel = parts.join(" ¬∑ ");
          subEdgeTitle = parts.map(p => "<b>" + p.split(":")[0] + "</b>: " + (p.split(":")[1] || "").trim()).join("<br>");
        }
        addEdge(tname, sname, subEdgeLabel, subEdgeTitle);

        // Optional leaves (entities/notes) under Subtopic (no attribution here to keep it clean)
        const entities = Array.isArray(s.entities) ? s.entities : [];
        const notes    = Array.isArray(s.notes) ? s.notes : [];
        const leaves   = [];
        for (const x of entities) {
          if (typeof x === 'string') leaves.push(x);
          else if (x && (x.name || x.text)) leaves.push(x.name || x.text);
        }
        for (const y of notes) {
          if (typeof y === 'string') leaves.push(y);
          else if (y && (y.name || y.text)) leaves.push(y.name || y.text);
        }
        for (const leaf of leaves) {
          addNode(leaf, "leaf", leaf, null);
          addEdge(sname, leaf, "", "");
        }
      }
    }

    if (selectedTopic === "All Topics") {
      for (const t of (DATA.main_topics || [])) addTopicBranch(t);
    } else {
      const t = (DATA.main_topics || []).find(x => x.topic === selectedTopic);
      if (t) addTopicBranch(t);
    }

    // Cross-link relationships (attribution on those edges too), unless hidden
    if (!hideCrosslinks) {
      for (const r of (DATA.relationships || [])) {
        const frm = r.from, to = r.to; if (!frm || !to) continue;
        // Ensure nodes exist (type inference is minimal here)
        addNode(frm, "leaf", frm, null);
        addNode(to,  "leaf", to,  null);
        let lbl = "";
        let ttl = "";
        if (r.type) lbl = r.type;
        const by = r.initiated_by, at = r.initiated_at;
        const extras = [];
        if (by) extras.push("by " + by);
        if (at) extras.push("at " + at);
        if (extras.length) lbl = (lbl ? lbl + " ¬∑ " : "") + extras.join(" ");
        if (r.type) ttl += "<b>type</b>: " + r.type;
        if (by)     ttl += (ttl ? "<br>" : "") + "<b>by</b>: " + by;
        if (at)     ttl += (ttl ? "<br>" : "") + "<b>at</b>: " + at;
        addEdge(frm, to, lbl, ttl);
      }
    }

    // Depth prune (root-out)
    const adj = new Map(); nodes.forEach(n => adj.set(n.id, []));
    edges.forEach(e => { if (adj.has(e.from)) adj.get(e.from).push(e.to); });
    const keep = new Set([root]); let frontier = [root], d=0;
    while (frontier.length && d < maxDepth) {
      const nxt = [];
      for (const u of frontier) {
        const kids = adj.get(u) || [];
        for (const v of kids) if (!keep.has(v)) { keep.add(v); nxt.push(v); }
      }
      frontier = nxt; d += 1;
    }
    const n2 = new vis.DataSet(nodes.get().filter(n => keep.has(n.id)));
    const kept = new Set(n2.getIds());
    const e2 = new vis.DataSet(edges.get().filter(e => kept.has(e.from) && kept.has(e.to)));

    return { nodes: n2, edges: e2 };
  }

  // -------- Render --------
  const container = document.getElementById('graph');
  let network = null;

  function render() {
    const opts = {
      selectedTopic: topicSel.value || "All Topics",
      maxDepth: parseInt(depthEl.value, 10),
      hideCrosslinks: hideX.checked,
      wrap: parseInt(wrapEl.value, 10),
      showEdgeLabels: edgeLabels.checked
    };
    const data = buildData(opts);

    const options = {
      layout: {
        hierarchical: {
          enabled: true,
          direction: dirEl.value,   // "LR" or "UD"
          sortMethod: "hubsize",
          levelSeparation: 230,
          nodeSpacing: 210,
          treeSpacing: 280
        }
      },
      physics: { enabled: false },
      nodes: {
        shape: "box",
        color: {
          border: "#ECEFF1",
          highlight: { border: "#90CAF9", background: "#E3F2FD" }
        },
        widthConstraint: { maximum: 260 }
      },
      edges: {
        smooth: { type: "continuous" },
        color: { color: getComputedStyle(document.documentElement).getPropertyValue('--edge').trim() },
        arrows: { to: { enabled: false } },
        font: { align: "top", size: 11, color: "#546E7A", background: "#FAFAFA" }
      },
      interaction: { hover: true, tooltipDelay: 80 }
    };

    container.innerHTML = "";
    network = new vis.Network(container, data, options);

    // Client-side highlight
    const q = (searchEl.value || "").trim().toLowerCase();
    if (q) {
      const ids = data.nodes.getIds();
      for (const id of ids) {
        const n = data.nodes.get(id);
        const lbl = (n.title || "").toLowerCase();
        if (lbl.includes(q)) {
          data.nodes.update({ id, color: getComputedStyle(document.documentElement).getPropertyValue('--highlight').trim() });
        }
      }
    }

    statsEl.textContent = data.nodes.length + " nodes ¬∑ " + data.edges.length + " edges";
  }

  // Events
  [topicSel, depthEl, wrapEl, dirEl, hideX, edgeLabels].forEach(el => el.addEventListener('input', render));
  searchEl.addEventListener('input', render);

  // Init
  topicSel.value = "All Topics";
  render();
</script>
</body>
</html>
